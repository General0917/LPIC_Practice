## chapter1

## 1-1
- シェル変数の一覧を表示するには、**set**コマンドラインを使用する
  - シェル変数
    - 設定されたシェルだけが使用する変数である
    - 子プロセスには引き継がれない
  - 環境変数
    - 設定されたシェルとそのシェルで起動したプログラムが使用する変数である
    - 子プロセスに引き継がれる
    - **export**コマンドにより定義(作成)する

  - setコマンド
    - 現在のシェルで定義されているシェル変数の一覧を表示する
    - 引数なしで実行する
    - シェル変数の値を定義するには、「シェル変数名=値」とする
    - 値の参照には、「$シェル変数名(または、${シェル変数名})」とする
    - シェル変数の削除にはunsetコマンドを使用する

  - 主なシェル変数
    | 変数名 | 説明 |
    | ---- | ---- |
    | PWD | カレントディレクトリの絶対パス |
    | PATH | コマンド検索パス |
    | HOME | ユーザーのホームディレクトリ |
    | PS1 | プロンプトを定義 |
    | PS2 | 2次プロンプトを定義 |
    | HISTFILE | コマンド履歴を格納するファイルを定義 |
    | LANG | 言語情報 |

### 1-2
- 現在の作業ディレクトリを表示するコマンドは、**echo ${PWD}**と、**PWD**である
  - 1-1の問題を参照する
  - echo
    - コマンドラインに変数を出力する
    - echo ${PWD}を実行すると、作業ディレクトリが表示される

### 1-3
- 現在のシェルに、パラメータやオプションを設定するコマンドは、**set**コマンドである
  - 1-1の問題を参照する
  - setコマンド
    - オプションを指定せずに実行すると、シェル変数、シェル関数を一覧表示する
    - オプションを指定すると、シェルのパラメータなどを設定可能
  - 主なオプション
    | オプション | 説明 |
    | ---- | ---- |
    | -o シェルオプション | シェルオプションを有効にする |
    | +o シェルオプション | シェルオプションを無効にする |

  - 主なシェルオプション
    | シェルオプション | 説明 |
    | ---- | ---- |
    | noclobber(-C) | リダイレクション(>)による既存のファイルへの上書きを禁止する |
    | histexpand(-H) | 「!番号」による履歴参照を行う(デフォルトで有効) |

## 1-4
- exportコマンドの目的として適切なものは、**シェル変数を環境変数に設定し、bashから起動するアプリケーションが参照できるようにする**である
  - exportコマンド
    - 環境変数を設定できる
    - 環境変数は子プロセスとして起動したアプリケーションに引き継がれるので、アプリケーションから利用できる

## 1-5
- bashシェルを使用している場合、次の設定(PS1='[\u@\h \w]')の意味で適切なものは、**bashシェルのコマンドプロンプトを設定している**である
  - bash
    - シェル変数PS1はコマンドプロンプト、シェル変数PS2は2次プロンプトとして定義されている
    - 2次プロンプトは、まだコマンドラインが完了せず、継続行であることを表す
    - CentOSでは、PS1のデフォルト値は「'\s-\v\$'」、PS2のデフォルト値は「'>'」である
  - プロンプト定義で使える表記
    | 主な表記 | 説明 |
    | ---- | ---- |
    | \s | シェルの名前 |
    | \v | bashのバージョン |
    | \u | ユーザー名 |
    | \h | ホスト名のうちの最初の . まで |
    | \w | 現在の作業ディレクトリ |

## 1-6
- 「cd ~yuko」コマンドを実行した際に適切なものは、**ユーザーyukoのホームディレクトリに移動する**である
  - cdコマンド
    - ファイルシステム内を移動する際に使用されるコマンド
  - ディレクトリに関する特殊記号
    | 記号 | 読み方 | 説明 | 
    | ---- | ---- | ---- |
    | / | スラッシュ | ルートディレクトリ。ファイルシステムの頂点(ルート)を表す |
    | ~ | チルダ | ホームディレクトリ。実行ユーザーの作業用ディレクトリを表す | 
    | . | ドット | カレントディレクトリ。実行ユーザーが作業を行っているディレクトリを表す |
    | .. | ドットドット | 親ディレクトリ。あるディレクトリを起点として、1つ上の階層にあるディレクトリを表す |

## 1-7
- manコマンドが実行時に参照するドキュメントファイルの置かれている場所として適切なものは、**/usr/share/man**と、**/usr/local/share/man**である
  - manコマンド
    - 引数で指定したコマンドのオンラインマニュアルを表示する
    - manコマンドの構文
      - man [オプション] [セクション] コマンドまたはキーワード
      - 主なオプション
        | オプション | 説明 |
        | ---- | ---- |
        | -f(--whatis) | キーワードと完全に一致するマニュアルが何セクションにあるか表示する |
        | -k(--apropos) | キーワードを含むマニュアルが何セクションにあるか表示する |
      - スクロール操作
        - マニュアルページが1画面で表示できない場合、manコマンドは1画面分を表示したところで一度表示を停止する
        - スクロール操作には次のキーを使用する
      - キー操作
        | 主なキー操作 | 説明 |
        | ---- | ---- |
        | Space | 次のページを表示 |
        | Enter | 次の行を表示 |
        | b | 前のページを表示 |
        | h | ヘルプを表示 |
        | q | manコマンドの終了 |
        | /文字列 | 指定した文字列で検索(nキーで次の検索) |

## 1-8
- あるコマンドの第1セクションのマニュアルを表示するコマンドとして適切なものは、**man 1 command**である
  - 1-7の問題を参照する

## 1-9
- コマンドの実行履歴が保存されているファイルとして適切なものは、**~/.bash_history**である
  - .bash_historyファイル
    - コマンド実行履歴の保存先は、デフォルトで「**~/.bash_history**」が使用される
    - bashのシェル変数HISTFILEのデフォルト値は「**~/.bash_history**」である
  - historyコマンド
    - コマンドの実行履歴を表示するコマンド
    - 引数を指定しない場合は、保存されている履歴をすべて表示するが、引数に履歴数を指定することで新しい履歴から指定された数の履歴を表示する
    - historyコマンドの構文
      - history [オプション] [履歴数]
      - 主なオプション
        | オプション | 説明 |
        | ---- | ---- |
        | -c | そのシェルの実行履歴を消去する |
        | -d [履歴番号] | 指定した履歴番号のコマンドをそのシェルの履歴から消去する |
      - キー操作
        | 主なキー操作 | 説明 |
        | ---- | ---- |
        | ↑(上矢印キー) | 一つ前のコマンドを表示する |
        | ↓(下矢印キー) | 一つ後のコマンドを表示する |
        | !! | 直前に実行したコマンドを表示する |
        | ![履歴番号] | 指定された履歴番号のコマンドを実行する |
        | ![文字列] | 指定した文字列から始まる直近のコマンドを実行する |

## 1-10
- あなたは現在、一般ユーザーであるyukoとしてシステムにログインしている。しかし都合により、現在のシェルを終了することなくrootの権限と環境でログインしなおす必要がある。適切なものは、**su - root**である
  - suコマンド
    - 一時的に他のユーザーの権限に切り替える場合に**su**コマンドを利用する
    - 「**su -**」の場合でも、rootユーザーにログインする
    - コマンドの構文
      - su [オプション] [変更先ユーザー名]
  - sudoコマンド
    - 事前に管理者から許可されている管理用コマンドを実行する

## 1-11
- ユーザーyukoは自分のホームディレクトリ下にdir_b/subdirを作成したいが、dir_bは存在していません。dir_b/subdirを作るために適切なものは、**mkdir -p /home/yuko/dir_b/subdir**である
  - mkdirコマンド
    - ディレクトリを作成する
    - コマンドの引数に複数のディレクトリ名を指定すると、一度に複数のディレクトリを作成することができる
    - コマンド引数に、**-p**を指定すると、パス途中のディレクトリも作成することができる
    - コマンドの構文
      - mkdir [オプション] ディレクトリ名...n
    - 主なオプション
      | オプション | 説明 |
      | ---- | ---- |
      | -m [アクセス権] | 明示的にアクセス権を指定してディレクトリを作成する |
      | -p | 中間ディレクトリを同時に作成する |

## 1-12
- /tmp/A ディレクトリの中にあるすべてのファイル・サブディレクトリをカレントディレクトリに移動させたい場合、適切なものは、mv -f /tmp/A/*.である
  - mvコマンド
    - ファイルやディレクトリの移動に使用されるコマンド
    - mvコマンドの最後の引数に指定されたディレクトリに移動元のファイル(またディレクトリ)が同じ名前で移動する
    - コマンドの構文
      - mv [オプション] 移動元ファイル名...n ディレクトリ名
      - mv [オプション] 移動元ディレクトリ...n ディレクトリ名
    - 主なオプション
      | オプション | 説明 |
      | ---- | ---- |
      | -i | 移動元に同名ファイルが存在する場合、上書きするか確認する |
      | -f | 移動元に同名ファイルが存在しても、強制的に上書きする |
    - 主なワイルドカード
      | 記号 | 説明 |
      | ---- | ---- |
      | ? | 任意の1文字 |
      | * | 0文字以上の文字列 |
      | [...] | []内に含まれる任意の1文字 |
      | [!...] | []内に含まれない任意の1文字 |
    - チルダ --- ホームディレクトリの省略表現
      | 記号 | 説明 |
      | ---- | ---- |
      | ~ | ホームディレクトリ。実行ユーザーの作業用ディレクトリを表す |
    - ダラー --- 置換
      | 記号 | 説明 |
      | ---- | ---- |
      | $ | 変数の置換(変数を参照して値に置換)や、コマンドの置換(ヒストリを参照した置換)などを行う |
    - クォート --- 特定の文字列をリテラルとして使用
      | 記号 | 説明 |
      | ---- | ---- |
      | '(シングルクォート) | 強いクォート(変数が展開されず、文字列として認識される) |
      | "(ダブルクォート) | 弱いクォート(変数が展開され、変数として認識される) |
      | ` | コマンド置換(シングルクォート内で、バッククォートが展開されていたら、文字列として認識される。また、ダブルクォート内で、バッククォートが展開されていたら、変数として展開される) |

## 1-13
- 

## chapter3

### 3-1
- システムでアクティブなプロセスをすべて表示するコマンドラインは、**ps ax**と**ps -ef**、**pstree**である
  - プロセス
    - 実行中のプログラムのことである
    - 主なプロセスを表示するコマンド
      | 主なコマンド | 説明 |
      | ---- | ---- |
      | ps | プロセスの情報を表示する基本的なコマンド |
      | pstree | プロセスの階層情報を表示する |
      | top | プロセスの情報を周期的にリアルタイムに表示する |

    - 主なオプション
      | 種類 | 主なオプション | 説明 | 
      | ---- | ---- | ---- |
      | UNIX | -e | 全てのプロセスを表示する |
      |  | -f | 詳細情報(完全なフォーマットでプロセス)を表示する | 
      |  | -l | 長いフォーマットで詳細情報を表示する |
      |  | -o | ユーザー定義のフォーマットで表示する |
      | BSD | a | 全てのプロセス(他のユーザーのプロセス)を表示する |
      |  | f | プロセスの親子関係をツリー状で表示する |
      |  | l | プロセスのnice値を表示する |
      |  | u | 詳細情報(プロセスの実行ユーザー名)を表示する |
      |  | x | 制御端末のないプロセス情報も表示する |

    - psコマンドを使用した際の主な表示項目
      | 主な項目 | 説明 |
      | ---- | ---- |
      | PID | プロセスID |
      | TTY | 制御している端末 |
      | TIME | 実行時間 |
      | CMD | コマンド(実行ファイル名) |

### 3-2
- 現在のシェルで実行中のプロセスの優先度を確認するためのコマンドラインとして、適切なものは、**ps -l**と**top**である
  - プロセスの優先度
    - プロセスの優先度は、**NI(nice)値**で表す

### 3-3
- オプションを指定せずにプロセスをツリー構造で表示するコマンドは、**pstree**である
  - 3-1の問題を参照する
  - pstreeコマンドでの主なオプション
    | オプション | 説明 |
    | ---- | ---- |
    | -h | カレントのプロセスとその先祖プロセスを強調表示 |
    | -H PID | 指定したプロセスとその先祖プロセスを強調表示 |
    | -p | プロセスをIDを付けて表示 |

### 3-4
- initのプロセスIDとして適切なものは、**1**である
  - 基本プロセス(処理)が開始されるときは、数字の**1**から開始される

### 3-5
- プロセスのプライオリティ(優先度)をデフォルトから変更するコマンドは、**nice**である
  - 優先度は、**動的優先度**と**静的優先度**がある
    | 優先度 | 説明 |
    | ---- | ---- |
    | 動的優先度 | 静的優先度とCPU使用時間を基に計算され、CPUを使うほど優先度は低くなる。カーネル内部で100 ~ 139の範囲の値を持つ |
    | 静的優先度 | nice値により一定範囲でユーザーが設定可能。カーネル内部で100 ~ 139の範囲の値を持つ |
    
  - niceコマンドの主なオプション
    | オプション | 説明 |
    | ---- | ---- |
    | -c(--adjustment) 優先度 | 優先度(-20 ~ 19)を指定する |

  - niceの設定仕様
    - nice値は、**-20 ~ 19**の値で変更可能
    - niceコマンドで、オプションで数値を指定しない場合のnice値は**10(0 + 10)**の優先度を付与する

### 3-6
- プロセスのプライオリティ(優先度)を変更する場合、設定可能な最大値は、**19**である
  - 3-5の問題を参照する

### 3-7
- 実行中のプロセスの優先度を変更するコマンドとして適切なものは、**top**と**renice**である
  - reniceコマンドの主なオプション
    | オプション | 説明 |
    | ---- | ---- |
    | -n 優先度 | 優先度(nice値)を指定する |
    | -p プロセスID | 対象のプロセスIDを指定する |
    | -g グループID | 対象プロセスのグループIDを指定する |
    | -u ユーザー | 対象プロセスのユーザーIDまたはユーザー名を指定する |
    
  - reniceコマンドの構文
    - renice [オプション] nice値 オプション 

  - topでの優先度変更方法
    - ➀topコマンドを実行後プロセス情報が表示されたら、キーボードから[r]キーをタイプする
    - ➁画面に「PID to renice:」が表示されるので、変更したいプロセスのPID(プロセスID)を入力し[Enter]を押下する
    - ➂画面に「Renice PID [指定したPID] to value:」が表示されるため、優先度を入力し[Enter]を押下する

### 3-8
- バックグラウンドで動作しているジョブをフォアグラウンドで動かすコマンドとして適切なものは、**fg**である
  - ジョブ
    - コマンドライン1行で実行された処理単位のことである
    - ジョブはシェルごとに管理され、「ジョブID」が振られる
    - 1行のコマンドラインで複数のコマンドが実行された場合でも、その処理全体を1つのジョブとして扱う
    - ジョブの種類は、**フォアグラウンドジョブ**と**バックグラウンドジョブ**の2種類がある
      | ジョブ | 説明 |
      | ---- | ---- |
      | フォアグラウンドジョブ | キーボードと端末情報を占有して対話的な操作をするジョブ。そのジョブが終了するまで端末画面上には次のプロンプトが表示されない。シェルごとに1つのみ |
      | バックグラウンドジョブ | キーボード入力を受け取ることができないジョブ。画面への出力設定によっては抑制される。複数のジョブを同時に実行することが可能。**バックグラウンドでジョブ(コマンド)を実行する際には、コマンドの末尾に「&」を付ける。** |
    - ジョブを制御する主なコマンド
      | コマンド | 説明 |
      | ---- | ---- |
      | jobs | バックグラウンドジョブと一時停止中のジョブを表示 |
      | Ctrl + z | 実行しているジョブを一時停止にする |
      | bg %ジョブID | 指定したジョブをバックグラウンドに移行 |
      | fg %ジョブID | 指定したジョブをフォアグラウンドに移行 |

### 3-9
以下のような実行例がある
```
$ myapp
[1] + 停止 myapp
$
```
- ユーザーからのコマンド入力を可能にしたままで、停止しているmyappを再開させるコマンドラインとして適切なものは、**bg myapp**である
  - 3-8の問題を参照する

### 3-10
- 現在バックグラウンドで走っているジョブをすべて表示するコマンドは、**jobs**である
  - 3-8の問題を参照する

### 3-11
- ログアウトした後もコマンドが終了することなく、バックグラウンドで実行を続けさせるコマンドラインとして適切なものは、**nohup コマンド名 &**である。
  - nohupコマンド
    - ログアウトしてもプログラムを実行し続けるには、**nohup**コマンドを使用する
    - 標準出力と標準エラー出力は、カレントディレクトリに「nohup.out」というファイル名でリダイレクトする
    - 書き込めない場合は、ホームディレクトリへ「nohup.out」というファイル名でリダイレクトする
    - コマンドの構文
      - nohup コマンド [引数]

### 3-12
- 「kill プロセスID」を実行したときにプロセスに送られるシグナルとして適切なものは、**SIGTERM(15)**である
  - シグナル
    - 割り込みによってプロセスに特定の動作をするように通知するための仕組みである
    - 通常、プロセスは処理を終えると自動的に消滅するが、プロセスに対してシグナルを送信することで外部からプロセスを終了することができる
    - シグナルは、キーボードによる操作や「kill コマンド」の実行などにより、実行中のプロセスに送信される
    - 主なシグナル
      | シグナル番号 | シグナル名 | 説明 | 
      | ---- | ---- | ---- |
      | 1 | SIGHUP | 端末の切断によるプロセスの終了 |
      | 2 | SIGINT | 割り込みによるプロセスの終了([Ctrl] + [c]で使用) | 
      | 9 | SIGKILL | プロセスの強制終了 |
      | 15 | SIGTERM | プロセスの終了(デフォルト)(killコマンドを実行した際に送られる) |
      | 18 | SIGCONT | 一時停止したプロセスを再開する |
      | 19 | SIGSTOP | 一時停止 |
      | 20 | SIGTSTP | 端末から入力された一時停止([Ctrl] + [z]で使用) |

    - killコマンド
      - 指定したプロセスIDのプロセスを終了させる
      - 主なオプション
        | オプション | 説明 |
        | ---- | ---- |
        | -s | 	指定したシグナル名またはシグナル番号を送信する |
        | -シグナル | 指定したシグナル名またはシグナル番号を送信する |
        | -l [] | シグナル名とシグナル番号の対応を表示する |
      - シグナルの送信には、killコマンドの他、**killall**コマンドも使用可能
      - コマンドの構文
        - kill [オプション] [シグナル名 | シグナル番号] プロセスID
        - kill [オプション] [シグナル名 | シグナル番号] %ジョブID
        - killall [オプション] [シグナル名 | シグナル番号] プロセス名

### 3-13
- 「kill 1234」と同じ動きをするコマンドラインとして適切なものは、**「kill -15 1234」**と、**「kill -s SIGTERM 1234」**である
  - 3-12の問題を参照する
    - killコマンドを明示的にシグナルを指定しない場合は、**SIGTERM(15)**が送信される
    - -sオプションは、シグナルを送信するオプションで省略可能

### 3-14
- [Ctrl] + [c]で送信されるシグナル番号として適切なものは、**SIGINT(2)**である
  - 3-12の問題を参照する
    - [Ctrl] + [z]が押された場合は、**SIGTSTP(20)**が送信される

### 3-15
- あるプロセスのPIDが1023のとき、このプロセスを終了させたいが、終了時にそのプロセスによるクリーンアップ(終了処理)を実行させる際のコマンドラインとして適切なものは、**kill -15 1023**または、**kill -SIGTERM 1023**である
  - 3-12の問題を参照する
    - クリーンアップ
      - 使っていたリソースの開放やロックファイルの削除などを行う
      - SIGTERM(15)でプロセスが終了しないような、やむを得ない場合は**SIGKILL(9)**を使用して強制終了する

### 3-16
- SIGUSR1シグナルをapache2という名前のプロセスに送信させる際のコマンドラインとして適切なものは、**killall -SIGUSR1 apache2**である
  - killallコマンド
    - 同じ名前のプロセスが複数存在し、それらをまとめて終了したい場合に利用する
    - また、killallコマンドと同様の処理を行う**pkill**コマンドや、プロセス名から現在実行中のプロセスを検索する**pgrep**コマンドも提供される
    - コマンドの構文
      - killall [オプション] [シグナル名 | シグナル番号] プロセス名

  - pkillコマンド
    - プロセスを指定して、終了シグナル(TERMシグナル)などの「シグナル」を送信するコマンドである
    - killallコマンドと違い、pkillコマンドの場合は対象とするプロセス名を正規表現で指定する
      - 例えば、「**pkill abc**」の場合は、「名前にabcを含むすべてのプロセス」が対象になる
    - コマンドの構文
      - pkill [オプション] [プロセス名などのパターン]
    - 主なオプション
      | オプション | 説明 |
      | ---- | ---- |
      | -(--signal) シグナル | 送信するシグナルを番号またはシグナル名で指定する |
      | -e(--echo) | 対象となったプロセスとプロセスIDを表示する |
      | -c(--count) | 該当するプロセス（シグナルを送ったプロセス）の個数を表示する |

  - pgrepコマンド
    - 現在実行中のプロセスを調べてユーザー名、UID、GIDなどを基にプロセスIDを検索する
    - コマンドの構文
      - pgrep [オプション] [パターン]
    - 主なオプション
      | オプション | 説明 |
      | ---- | ---- |
      | -t 端末 | 指定した端末で実行されているプロセスIDを検索する。「.」区切りで複数指定可能 |
      | -u euid | 指定された実行ユーザーIDに該当するプロセスIDを検索する。ユーザーは名前またはIDで指定し、「,」区切りで複数指定可能 |
      | -U uid | 指定された実ユーザーIDに該当するプロセスIDを検索する。ユーザーは名前またはIDで指定し、「,」区切りで複数指定可能 |

### 3-17
- jobsコマンドを実行すると以下のように表示される
  ```
  $ jobs
  [1] Running prog &
  [2] - Running search &
  [3] + Running top &
  ```
  上記のジョブのうち、topジョブを終了させるコマンドラインとして適切なものは、**kill %3**である
  - 3-12の問題を参照する
  - コマンドの構文
    - kill [オプション] [シグナル名 | シグナル番号] %ジョブID

### 3-18
- 特定のコマンドを秒数を指定し繰り返し実行させて、結果を端末に表示するコマンドは、**watch**である
  - watchコマンド
    - 指定されたコマンドを繰り返し実行し、その結果を表示する
    - プログラムの出力の経時変化を監視できる
    - デフォルトでは2秒おきに実行されるが、時間の間隔を変えたい場合は-nまたは--intervalを指定する
    - watchコマンドは中断([Ctrl] + [c])されるまで実行を続ける

### 3-19
- tmuxコマンドの説明で誤っているものは、**GUI端末の画面制御プログラム**である
  - tmux
    - 1つの物理的な端末画面から多数の端末を作成、アクセス、および制御することができる文字型端末の画面制御プログラムである
    - 1つの画面の中で複数の画面を起動して作業可能
    - sshによるリモートログイン時でも同様に利用可能
    - tmuxで使用される用語
      | 用語 | 説明 |
      | ---- | ---- |
      | セッション | tmuxの管理下にある仮想端末の単一の集合 |
      | ウインドウ | セッション内で管理される仮想ウインドウ |
      | デタッチ | セッションから切断 |
      | アタッチ | デタッチしたセッションに再接続 |
    - tmuxと同様の機能を提供するものとして「screen」コマンドもある
