# 7日目

## 1 プロセスとジョブ

### 1-1 プロセスの管理
- 実行中のプログラムを**プロセス**という
  - **プロセス**
    - プログラムは通常、ファイルの形でハードディスクをはじめとするストレージに保存される
    - プログラムを実行すると、そのプログラムコードがコンピュータのメモリ上に読み込まれ、CPUによって実行される
    - このメモリ上で実行中のプログラムのことを**プロセス**という
- プロセスには固有のプロセスIDが付与される
  - **プロセスID**
    - プロセスを起動すると、プロセスごとに固有のID番号が割り当てられる
    - これを**プロセスID(PID)**という
    - プロセスIDはプロセスを特定するために利用できる
    - 同じ名前のプログラムが複数実行されていても、それらを識別できるわけである
- **ps**コマンドでプロセス情報を表示できる
  ```
  # プロセス情報を表示する際の書式コマンド
  $ ps [オプション]

  # プロセス情報を表示
  # オプションなしでpsコマンドを実行すると、psコマンドを実行したユーザーがその端末上で起動したプロセスの一覧が表示される
  $ ps
    PID TTY          TIME CMD
    9 pts/0    00:00:00 bash
   32 pts/0    00:00:00 ps

  # 全てのプロセスを表示
  $ ps aux
  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
  root         1  0.0  0.0   2324  1508 ?        Sl   05:07   0:00 /init
  root         4  0.0  0.0   2324     4 ?        Sl   05:07   0:00 plan9 --control-socket 5 --log-level 4 --server-fd 6 --root         7  0.0  0.0   2332   112 ?        Ss   05:07   0:00 /init
  root         8  0.0  0.0   2348   120 ?        S    05:07   0:00 /init
  general+     9  0.0  0.0   8272  5120 pts/0    Ss   05:07   0:00 -bash
  general+    33  0.0  0.0  10084  3368 pts/0    R+   05:22   0:00 ps aux
  ```
  - psコマンドの主な表示項目
    | 項目 | 説明 |
    | ---- | ---- |
    | PID | プロセスID |
    | TTY | プロセスを実行した端末名 |
    | TIME | プロセス実行時間 |
    | CMD | 実行コマンド |

  - psコマンドの主なオプション
    | オプション | 説明 |
    | ---- | ---- |
    | a | 他のユーザーのプロセスも表示する |
    | u | ユーザー名を表示する |
    | x | 端末から実行されたものではないプロセス(サーバプロセスなど)も表示する |
- **pstree**コマンドでプロセスの親子関係を表示することができる
  - プロセスは、実行中のほかのプロセスから起動される
  - これを**フォーク**といい、起動元のプロセスを**親プロセス**、親プロセスから起動したプロセスを**子プロセス**という
  - プロセスの親子関係は、**pstree**コマンドを使うとよくわかる
    ```
    # プロセスの親子関係を表示するコマンド書式
    pstree [オプション]

    $ pstree
    init(CentOSStre─┬─SessionLeader───Relay(9)───bash───pstree
                ├─SessionLeader───Relay(36)───bash
                ├─init───{init}
                └─{init(CentOSStre}
    ```
  - 主なオプション
    | オプション | 説明 |
    | ---- | ---- |
    | -a | コマンドラインの引数を表示する |
    | -c | 同じ内容のサブツリーをまとめず表示する |
    | -h | カレントプロセスとその先祖のプロセスを強調表示する |
    | -l | 長い行を表示する。デフォルトでは、長い行はディスプレイの幅で切られる |
    | -n | 同じ親を持つプロセスを、名前ではなくPIDでソートする |
    | -p | PIDを表示する |
    | -u | ユーザーIDを表示する |

- **top**コマンドでプロセスの実行状況をモニターできる
  ```
  # プロセスの実行状況を確認するコマンド書式
  top

  # topコマンドの出力例
  $ top
  top - 05:36:30 up 11:14,  0 users,  load average: 0.07, 0.22, 0.16
  Tasks:   9 total,   1 running,   8 sleeping,   0 stopped,   0 zombie
  %Cpu(s):  0.6 us,  0.8 sy,  0.0 ni, 98.3 id,  0.1 wa,  0.0 hi,  0.2 si,  0.0 st
  MiB Mem :  15998.8 total,  10346.5 free,   2617.4 used,   3377.0 buff/cache
  MiB Swap:      0.0 total,      0.0 free,      0.0 used.  13381.3 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
      1 root      20   0    2324   1508   1404 S   0.0   0.0   0:00.00 init(CentOSStre
      4 root      20   0    2324      4      0 S   0.0   0.0   0:00.00 init
      7 root      20   0    2332    112      0 S   0.0   0.0   0:00.00 SessionLeader
      8 root      20   0    2348    120      0 S   0.0   0.0   0:00.00 Relay(9)
      9 general+  20   0    8272   5120   3608 S   0.0   0.0   0:00.01 bash
    34 root      20   0    2332    112      0 S   0.0   0.0   0:00.00 SessionLeader
    35 root      20   0    2348    120      0 S   0.0   0.0   0:00.00 Relay(36)
    36 general+  20   0    8272   5124   3612 S   0.0   0.0   0:00.00 bash
    61 general+  20   0   10496   3952   3252 R   0.0   0.0   0:00.00 top
  ```
  - topコマンドの主な表示項目
    | 表示項目 | 説明 |
    | ---- | ---- |
    | PID | プロセスID |
    | USER | プロセスを実行しているユーザー |
    | %CPU | CPUを消費している割合 |
    | %MEM | メモリを消費している割合 |
    | COMMAND | 実行されているコマンド |
- **kill**コマンドでプロセスを終了させることができる
  - プログラムの実行が終了すると、プロセスは消滅する
  - プロセスの中には、各種サーバプロセスやシステムプロセスなど、明確に終了を指示しなければ動作し続けるものもある
  - また、プログラムの不具合が原因で、異常動作を起こして終了しなくなることもある
  - こういった場合は、プロセスに停止信号を送って終了させることになる
  - プロセスをに送る信号のことを**シグナル**という。主なシグナルは次のとおりである
    | シグナルID | シグナル名 | 動作 | 
    | ---- | ---- | ---- |
    | 1 | HUP | 再起動 |
    | 6 | ABRT | 中断 |
    | 9 | KILL | 強制終了 |
    | 15 | TERM | 終了(デフォルト) |
    | 18 | CONT | 再開 |
    | 19 | STOP | 一時停止 |
  - シグナルを送信するには**kill**コマンドを利用する
    ```
    # シグナルを送信する際のコマンド書式
    kill -[シグナルID] プロセスID
    kill -s [シグナル名] プロセスID

    # プロセスIDが28000のプロセスを終了する際には以下のいずれかを実行する

    # プロセスの終了➀
    $ kill 28000

    # プロセスの終了➁
    $ kill -15 28000

    # プロセスの終了➂
    $ kill -s TERM 28000

    # プロセスの強制終了➀
    $ kill -9 28000

    # プロセスの強制終了➁
    $ kill -s KILL 28000
    ```
  - 主なオプション
    | オプション | 説明 |
    | ---- | ---- |
    | -s シグナル名 | 指定したシグナル名を送信する |
    | -シグナルID | 指定したシグナルIDを送信する |
    | -l [] | シグナル名とシグナル番号の対応を表示する |
- **killall**コマンドでプロセスIDではなく、プロセス名を指定してプロセスを終了することができる
  - ただし、同じ名前のプロセスが複数実行されている場合は、それらすべてにシグナルが送られるので注意が必要!!
  ```
  # vimというプロセス名のプロセスを終了
  $ killall -15 kill
  ```

### 1-2 ジョブ管理
- ユーザーから見た処理の単位を**ジョブ**という
  - コンピュータに実行させる作業のまとまりを「**ジョブ**」と呼ぶ。例えば、コマンドラインでは「コマンドを入力してEnterキーを押す」と、1つのジョブが実行される
    - パイプ(|)でいくつかのコマンドをつないで実行する場合でも、それで1つのジョブと考える
  - ジョブには、**フォアグラウンドジョブ**と**バックグラウンドジョブ**がある
    - **フォアグラウンドジョブ**
      - 通常、コマンドライン上でコマンド(ジョブ)を実行すると、それが終了するまでは次のコマンドを入力することができない。
      - これが、**フォアグラウンド**でジョブが実行されている状態
    - **バックグラウンドジョブ**
      - 裏(バックグラウンド)でジョブを実行させることも可能
      - コマンドラインの末尾に「**&**」を付けるとバックグラウンドジョブとして実行される
        ```
        # バックグラウンドで実行
        # lessコマンドをバックグラウンドで実行すると、次のコマンドがすぐに入力できる状態になる
        $ less /etc/services &
        [1] 63
        $ 
        ```
- ジョブには端末ごとにジョブIDが付与される
- **jobs**コマンドでジョブ情報を表示できる
  ```
  # 実行中のジョブを確認するコマンド書式
  jobs

  $ jobs
  [1]+  Stopped                 less /etc/services
  ```
- ジョブをフォアグラウンドで実行させる場合は**fg**(ForeGround)コマンドを使う
  - ジョブIDは「%1」のように、パーセント記号「**%**」に続けて指定する。
  - 「**%**」を付けなければ、プロセスIDが指定されたものとみなされるので、注意が必要!!
  - フォアグラウンドでジョブが実行されている最中に「Ctrl + Z」キーを押すと、そのジョブは一時停止状態になる
  ```
  # ジョブをフォアグラウンドで実行する際のコマンド書式
  fg [%ジョブID]

  # 1番目のジョブをフォアグラウンドで実行
  $ fg %1
  ```

- フォアグラウンドで一時停止中のジョブの実行をバックグラウンドで再開させるには、**bg**(BackGround)コマンドを使う
  ```
  # ジョブをバックグラウンドで実行する際のコマンド書式
  bg [%ジョブID]

  # 1番目のジョブをバックグラウンドで実行
  $ bg %1
  ```

## 2 ネットワークの利用

### 2-1 ネットワークの基礎を理解しよう
- コンピュータ同士が理解できる約束事(ルール)を守ってメッセージをやり取りする方法を**プロトコル**という
  - 最も一般的なプロトコルは、インターネットの基盤となっている**TCP/IP**である
    - **TCP/IP**
      - これは、1つのプロトコルではなく、TCP及びIPという2つのプロトコルと、関連する多数のプロトコルを含めたプロトコル群を表す
  - プロトコルには以下のものがある
    - **TCP**
      - 
    - **IP**
      - 
    - **UDP**
      - 
    - **ICMP**
      - 
- IPアドレス(IPv4)の32ビットはネットワーク部とホスト部から構成される。境界はサブネットマスクで求められる
- ネットワークアドレスとブロードキャストアドレスはコンピュータに割り当てるIPアドレスとしては利用できない
- プライベートアドレスは自由に使ってよいIPアドレスである
- ポート番号でアプリケーションを識別する